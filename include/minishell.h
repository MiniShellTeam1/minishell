/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nico <nico@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 13:23:29 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/04 00:00:17 by nico             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

/* -------------------------- System Header Includes ------------------------- */
#include <stdlib.h>           // For memory allocation and standard utilities
#include <stddef.h>	          // For size_t type
#include <unistd.h>           // For POSIX system calls (e.g., write, read)
#include <dirent.h>           // For directory handling
#include <errno.h>            // For error number definitions
#include <readline/readline.h> // For readline functionality
#include <readline/history.h>  // For command history management
#include <stdio.h>            // For standard I/O operations
#include <fcntl.h>

/* ---------------------------- Error Message Macros ------------------------- */
/* Macros for standard error messages used throughout the Minishell project */
# define NO_SUCH_FILE_OR_DIRECTORY "No such file or directory\n" // Exit code: 1 or 127
# define PERMISSION_DENIED "Permission denied\n" // Exit code: 1 or 126
# define NOT_A_DIRECTORY "Not a directory\n" // Exit code: 1
# define TOO_MANY_ARGUMENTS "too many arguments\n" // Exit code: 1
# define ARGUMENT_LIST_TOO_LONG "Argument list too long\n" // Exit code: 1
# define TOO_MANY_LEVELS_OF_SYMB_LINK "Too many levels of symbolic links\n" // Exit code: 1
# define FILE_NAME_TOO_LONG "File name too long\n" // Exit code: 1
# define COMMAND_NOT_FOUND "command not found\n" // Exit code: 127

/* ------------------------- Enums and Struct Definitions -------------------- */

/* Enum for lexer state machine */
typedef enum {
    NORMAL,           // Default state for processing characters
    IN_SINGLE_QUOTE,  // Inside single-quoted string
    IN_DOUBLE_QUOTE,  // Inside double-quoted string
    IN_WORD,          // Processing a word token
    IN_OPERATOR       // Processing an operator token
} t_state;

/* Structure for token list generated by the lexer */
typedef struct {
    char    **tokens;    // Array of token strings
    size_t  count;       // Number of tokens
    size_t  capacity;    // Allocated capacity of the token array
} t_token_list;

/* Structure for environment variables (doubly linked list) */
typedef struct s_env {
    char            *key;    // Environment variable key (e.g., "PATH")
    char            *value;  // Corresponding value
    struct s_env    *prev;   // Pointer to previous env variable
    struct s_env    *next;   // Pointer to next env variable
} t_env;

/* Structure for a parsed command */
typedef struct s_command {
    char            *cmdpath;      // Full path to the command executable
    char            **args;        // Array of command arguments
    char            **infiles;     // Array of input file redirections
    char            **outfiles;    // Array of output file redirections
    char            *errormsg;     // Error message if command fails
    int             append;        // Flag for append mode (>>)
    char            *heredoc_input;// Heredoc input string
	int				is_heredoc;
    struct s_command *next;        // Pointer to next command in pipeline
} t_command;

/* Master structure to hold the shell state */
typedef struct s_master {
    struct s_command *cmds;      // Linked list of parsed commands
    struct s_env     *env;       // Linked list of environment variables
    unsigned char    errorcode;  // Last exit status code
	int				*pids;
} t_master;

/* Additional structures for norminette compliance */
typedef struct s_lexer_data {
    t_state         *state;
    const char      **input;
    t_token_list    *tokens;
    char            *buffer;
    size_t          *buf_pos;
} t_lexer_data;

typedef struct s_parser_data {
    t_command       **cmd;
    char            *token;
    int             *pipe_flag;
    t_master        *master;
} t_parser_data;

/* ---------------------------- Function Prototypes -------------------------- */

/* Utility Functions - utils_str1.c */
int     ft_strlen(const char *str);                // Get string length
int     ft_strcmp(char *str1, char *str2);         // Compare two strings
char    *ft_strjoin(const char *s1, const char *s2); // Join two strings

/* Utility Functions - utils_str2.c */
char    *ft_strdup(const char *s1);                // Duplicate a string
size_t  ft_strlcpy(char *dst, const char *src, size_t size); // Safe string copy
size_t  ft_strlcat(char *dst, const char *src, size_t size); // Safe string concatenation

/* Utility Functions - utils_str3.c */
int     ft_strncmp(const char *s1, const char *s2, size_t n); // Compare n chars of two strings
int     ft_strchr(char *str, char c);              // Find character in string
char    *ft_strndup(const char *s, size_t n);      // Duplicate n chars of a string

/* Utility Functions - utils_io.c */
void    ft_putstr_fd(char *str, int fd);           // Write string to file descriptor
char	**ft_split(char *tosplit, char seperator);

/* Utility Functions - utils_convert.c */
char    *ft_itoa(int num);                         // Convert integer to string
char    *ft_strjoin3(char *str1, char *str2, char *str3); // Join three strings

/* Lexer Functions - lexer_init.c */
t_token_list    *init_token_list(void);            // Initialize token list
int             add_token(t_token_list *tokens, char *buffer); // Add token to list
void            free_token_list(t_token_list *tokens); // Free token list memory

/* Lexer Functions - lexer_main.c */
t_token_list    *lexer(const char *input);         // Tokenize input string
int             process_char(t_lexer_data *data);  // Process a single character

/* Lexer Functions - lexer_state_normal.c */
int             handle_normal(t_lexer_data *data); // Handle normal state

/* Lexer Functions - lexer_state_quotes.c */
int             handle_single_quote(t_lexer_data *data); // Handle single quotes
int             handle_double_quote(t_lexer_data *data); // Handle double quotes

/* Lexer Functions - lexer_state_word.c */
int             handle_word(t_lexer_data *data);   // Handle word tokens
int             handle_operator(t_lexer_data *data); // Handle operators

/* Parser Functions - parser_init.c */
t_command       *init_command(void);               // Initialize a command structure
void            free_command(t_command *cmd);      // Free command memory
int             add_arg(t_command *cmd, char *arg); // Add argument to command

/* Parser Functions - parser_main.c */
t_command       *parser(t_token_list *tokens, t_master *master); // Parse tokens into commands

/* Parser Functions - parser_tokens.c */
int             process_token(t_command **cmd, char *token, int *pipe_flag, t_master *master); // Process a token
int             process_token_normal(t_parser_data *data); // Process normal token
int             process_token_variable(t_parser_data *data); // Process variable token

/* Parser Functions - parser_redirects.c */
int             set_redirect(t_command *cmd, char *token, char *next_token); // Set redirection

/* Parser Functions - parser_quotes.c */
char            *strip_quotes(char *token);        // Remove quotes from token
int             is_variable(char *token);          // Check if token is a variable
char            *expand_variable(char *token, t_master *master); // Expand variable

/* Executor Functions */
void			ft_exec(t_master *master);
void			ft_execpipe(t_master *master);
void			ft_execbuiltin(t_master *master);
int				ft_openinfiles(t_master *master, t_command currentcmd);
int				ft_openoutfiles(t_master *master, t_command currentcmd);
void			ft_checkcmdpath(t_master *master, t_command *currentcmd);
int				ft_isbuiltin(t_command cmd);
void	        ft_checkforcmdpath(t_master *master, t_command *currentcmd);
char	        **ft_getpathsarr(t_master master);

/* Heredoc functions*/
void            handle_heredoc(t_command *cmd, t_master *master);    // Handle heredoc input
int				is_quoted_delimiter(char *delimiter);

/* Built-in Functions */
int				ft_cd(t_master *master);
void            ft_echo(t_command cmd);            // Echo command built-in
void            ft_env(t_master master);           // Print environment variables
void            ft_exit(t_command cmd);            // Exit shell built-in
void            ft_export(t_master *master);       // Export environment variable
int             ft_pwd(void);                      // Print working directory
void            ft_unset(t_master *master);        // Unset environment variable

/* Environment Functions */
t_env           *ft_createenvlist(char **envp);    // Create env list from envp
void            ft_addvar(t_env **env, char *key, char *value); // Add env variable
void            ft_delvar(t_env **env, char *key); // Delete env variable
char            *ft_getkey(char *var);             // Get key from env string
char            *ft_getvalue(char *var);           // Get value from env string
void            ft_freevar(t_env *var);            // Free an env variable
char			*ft_getstralloc(char *str);
void 			ft_freeenv(t_master *master);
char			**ft_getenvarray(t_master *master);
int				ft_lstlen(t_master master);
char            *ft_addlvl(char *stringlvl);       // Increment SHLVL value

/* Signal Handling Functions */
void	setup_signals(void);
void	reset_signals(void);
int	check_signal(void);

/* Main Functions */
t_master        *init_master(void);                // Initialize master structure
void            free_master(t_master *master);     // Free master structure

/* Free functions */
void ft_freeandexit(t_master *master, unsigned char exitcode);
void ft_freecmds(t_master *master);
void ft_freechararr(char **array);

/* Error Handling */
void            ft_printerror(char *cmd, char *errfile, char *errormsg); // Print error message

/* Debug Functions */
void            print_tokens(t_token_list *tokens); // Print token list
void            print_parsed_commands(t_command *cmd); // Print parsed commands
void            print_master(t_master *master);    // Print master structure
void            debug_shell_state(t_token_list *tokens, t_command *cmd, t_master *master, const char *stage); // Debug shell state

#endif /* MINISHELL_H */