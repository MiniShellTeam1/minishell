# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    test.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#              #
#    Updated: 2025/05/02 15:32:46 by mhuthmay         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "minishell.h"

t_token_list *init_token_list(void)
{
    t_token_list    *list;

    list = malloc(sizeof(t_token_list));
    if (!list)
        return (NULL);
    list->tokens = malloc(sizeof(char *) * 10);
    if (!list->tokens)
        return (free(list), NULL);
    list->count = 0;
    list->capacity = 10;
    return (list);
}

int add_token(t_token_list *tokens, char *buffer)
{
    char    **new_tokens;
    char    *token;
    size_t  i;

    token = ft_strdup(buffer);
    if (!token)
        return (0);
    if (tokens->count >= tokens->capacity)
    {
        tokens->capacity *= 2;
        new_tokens = malloc(sizeof(char *) * tokens->capacity);
        if (!new_tokens)
            return (free(token), 0);
        i = 0;
        while (i < tokens->count)
        {
            new_tokens[i] = tokens->tokens[i];
            i++;
        }
        free(tokens->tokens);
        tokens->tokens = new_tokens;
    }
    tokens->tokens[tokens->count] = token;
    tokens->count++;
    return (1);
}

void free_token_list(t_token_list *tokens)
{
    size_t  i;

    i = 0;
    while (i < tokens->count)
    {
        free(tokens->tokens[i]);
        i++;
    }
    free(tokens->tokens);
    free(tokens);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_main.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: feanor <feanor@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 13:18:18 by feanor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int process_char(t_lexer_data *data)
{
    if (*(data->state) == NORMAL)
        return (handle_normal(data));
    if (*(data->state) == IN_SINGLE_QUOTE)
        return (handle_single_quote(data));
    if (*(data->state) == IN_DOUBLE_QUOTE)
        return (handle_double_quote(data));
    if (*(data->state) == IN_WORD)
        return (handle_word(data));
    return (handle_operator(data));
}

t_token_list *lexer(char const *input)
{
    t_state         state;
    char            *buffer;
    size_t          buf_pos;
    t_token_list    *tokens;
    t_lexer_data    data;

    if (!input)
        return (NULL);
    
    state = NORMAL;
    buffer = malloc(1024);
    if (!buffer)
        return (NULL);
    buf_pos = 0;
    tokens = init_token_list();
    if (!tokens)
    {
        free(buffer);
        return (NULL);
    }
    data.state = &state;
    data.input = &input;
    data.tokens = tokens;
    data.buffer = buffer;
    data.buf_pos = &buf_pos;

    while (*input)
    {
        if (!process_char(&data))
        {
            free(buffer);
            free_token_list(tokens);
            return (NULL);
        }
    }
    if (buf_pos > 0 && state == IN_WORD)
    {

        buffer[buf_pos] = '\0';
        if (!add_token(tokens, buffer))
        {
            free(buffer);
            free_token_list(tokens);
            return (NULL);
        }
    }
    
    free(buffer);
    return (tokens);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_state_normal.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 15:30:00 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int handle_normal(t_lexer_data *data)
{
    if (**(data->input) == ' ')
    {
        (*(data->input))++;
        return (1);
    }
    
    if (**(data->input) == '"')
    {
        *(data->state) = IN_DOUBLE_QUOTE;
        (data->buffer)[*(data->buf_pos)] = **(data->input);
        (*(data->buf_pos))++;
        (*(data->input))++;
        return (1);
    }
    
    if (**(data->input) == '\'')
    {
        *(data->state) = IN_SINGLE_QUOTE;
        (data->buffer)[*(data->buf_pos)] = **(data->input);
        (*(data->buf_pos))++;
        (*(data->input))++;
        return (1);
    }
    
    if (**(data->input) == '|' || **(data->input) == '<' || 
        **(data->input) == '>')
    {
        *(data->state) = IN_OPERATOR;
        (data->buffer)[*(data->buf_pos)] = **(data->input);
        (*(data->buf_pos))++;
        (*(data->input))++;
        return (1);
    }
    
    *(data->state) = IN_WORD;
    (data->buffer)[*(data->buf_pos)] = **(data->input);
    (*(data->buf_pos))++;
    (*(data->input))++;
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_state_quotes.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 15:30:00 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int handle_double_quote(t_lexer_data *data)
{
    const char **input_ptr = data->input;
    size_t *pos_ptr = data->buf_pos;
    data->buffer[*pos_ptr] = **input_ptr;
    (*pos_ptr)++;
    (*input_ptr)++;
    while (**input_ptr && **input_ptr != '"')
    {
        data->buffer[*pos_ptr] = **input_ptr;
        (*pos_ptr)++;
        (*input_ptr)++;
    }
    
    if (**input_ptr == '"')
    {
        data->buffer[*pos_ptr] = **input_ptr;
        (*pos_ptr)++;
        (*input_ptr)++;
        if (!**input_ptr || **input_ptr == ' ' || **input_ptr == '|' || 
            **input_ptr == '<' || **input_ptr == '>')
        {
            *(data->state) = NORMAL;
            data->buffer[*pos_ptr] = '\0';
            
            write(1, "handle_double_quote adding token: ", 34);
            write(1, data->buffer, ft_strlen(data->buffer));
            write(1, "\n", 1);
            
            if (!add_token(data->tokens, data->buffer))
                return (0);
            *pos_ptr = 0;
        }
        else
        {
            *(data->state) = IN_WORD;
        }
    }
    else
    {
        *(data->state) = NORMAL;
        data->buffer[*pos_ptr] = '\0';
        
        write(1, "handle_double_quote adding token (unclosed): ", 45);
        write(1, data->buffer, ft_strlen(data->buffer));
        write(1, "\n", 1);
        
        if (!add_token(data->tokens, data->buffer))
            return (0);
        *pos_ptr = 0;
    }
    
    return (1);
}

int handle_single_quote(t_lexer_data *data)
{
    const char **input_ptr = data->input;
    size_t *pos_ptr = data->buf_pos;
    data->buffer[*pos_ptr] = **input_ptr;
    (*pos_ptr)++;
    (*input_ptr)++;
    while (**input_ptr && **input_ptr != '\'')
    {
        data->buffer[*pos_ptr] = **input_ptr;
        (*pos_ptr)++;
        (*input_ptr)++;
    }
    
    if (**input_ptr == '\'')
    {
        data->buffer[*pos_ptr] = **input_ptr;
        (*pos_ptr)++;
        (*input_ptr)++;
        if (!**input_ptr || **input_ptr == ' ' || **input_ptr == '|' || 
            **input_ptr == '<' || **input_ptr == '>')
        {
            *(data->state) = NORMAL;
            data->buffer[*pos_ptr] = '\0';
            
            write(1, "handle_single_quote adding token: ", 34);
            write(1, data->buffer, ft_strlen(data->buffer));
            write(1, "\n", 1);
            
            if (!add_token(data->tokens, data->buffer))
                return (0);
            *pos_ptr = 0;
        }
        else
        {
            *(data->state) = IN_WORD;
        }
    }
    else
    {
        *(data->state) = NORMAL;
        data->buffer[*pos_ptr] = '\0';
        
        write(1, "handle_single_quote adding token (unclosed): ", 45);
        write(1, data->buffer, ft_strlen(data->buffer));
        write(1, "\n", 1);
        
        if (!add_token(data->tokens, data->buffer))
            return (0);
        *pos_ptr = 0;
    }
    
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_state_word.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 15:30:00 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int handle_word(t_lexer_data *data)
{
    if (!data || !data->buffer || !data->buf_pos || !data->input || !*(data->input))
        return (0);
    if (**(data->input) == ' ' || **(data->input) == '|' || 
        **(data->input) == '<' || **(data->input) == '>')
    {
        *(data->state) = NORMAL;
        (data->buffer)[*(data->buf_pos)] = '\0';
        
        write(1, "handle_word adding token: ", 26);
        write(1, data->buffer, ft_strlen(data->buffer));
        write(1, "\n", 1);
        
        if (!add_token(data->tokens, data->buffer))
            return (0);
        *(data->buf_pos) = 0;
        return (1);
    }
    if (*(data->buf_pos) < 1023)
    {
        (data->buffer)[*(data->buf_pos)] = **(data->input);
        (*(data->buf_pos))++;
        (*(data->input))++;
    }
    else
    {
        (*(data->input))++;
    }
    return (1);
}

int handle_operator(t_lexer_data *data)
{
    if (!data || !data->buffer || !data->buf_pos || !data->input || !*(data->input) || !data->state)
        return (0);
    
    if (*(data->buf_pos) == 1 && 
        (((data->buffer)[0] == '>' && **(data->input) == '>') ||
         ((data->buffer)[0] == '<' && **(data->input) == '<')))
    {
        if (*(data->buf_pos) < 1023)
        {
            (data->buffer)[*(data->buf_pos)] = **(data->input);
            (*(data->buf_pos))++;
            (*(data->input))++;
        }
        else
        {
            (*(data->input))++;
        }
    }
    else
    {
        *(data->state) = NORMAL;
        if (*(data->buf_pos) < 1024)
            (data->buffer)[*(data->buf_pos)] = '\0';
        
        write(1, "handle_operator adding token: ", 30);
        write(1, data->buffer, ft_strlen(data->buffer));
        write(1, "\n", 1);
        
        if (!add_token(data->tokens, data->buffer))
            return (0);
        *(data->buf_pos) = 0;
    }
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_init.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: feanor <feanor@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 11:13:46 by feanor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_command *init_command(void)
{
    t_command   *cmd;

    cmd = malloc(sizeof(t_command));
    if (!cmd)
        return (NULL);
    cmd->args = malloc(sizeof(char *) * 10);
    if (!cmd->args)
        return (free(cmd), NULL);
    cmd->args[0] = NULL;
    cmd->infiles = malloc(sizeof(char *) * 2);
    if (!cmd->infiles)
        return (free(cmd->args), free(cmd), NULL);
    cmd->infiles[0] = NULL;
    cmd->outfiles = malloc(sizeof(char *) * 2);
    if (!cmd->outfiles)
        return (free(cmd->args), free(cmd->infiles), free(cmd), NULL);
    cmd->outfiles[0] = NULL;
    cmd->cmdpath = NULL;
    cmd->errormsg = NULL;
    cmd->append = 0;
    cmd->heredoc_input = NULL;
    cmd->next = NULL;
    return (cmd);
}

void free_command(t_command *cmd)
{
    size_t  i;

    if (!cmd)
        return ;
    i = 0;
    while (cmd->args[i])
        free(cmd->args[i++]);
    free(cmd->args);
    i = 0;
    while (cmd->infiles[i])
        free(cmd->infiles[i++]);
    free(cmd->infiles);
    i = 0;
    while (cmd->outfiles[i])
        free(cmd->outfiles[i++]);
    free(cmd->outfiles);
    free(cmd->cmdpath);
    free(cmd->errormsg);
    free(cmd->heredoc_input);
    free_command(cmd->next);
    free(cmd);
}

int add_arg(t_command *cmd, char *arg)
{
    size_t  i;
    char    *dup;
    char    **new_args;

    dup = ft_strdup(arg);
    if (!dup)
        return (0);
    i = 0;
    while (cmd->args[i])
        i++;
    if (i >= 10)
    {
        new_args = malloc(sizeof(char *) * (i * 2));
        if (!new_args)
            return (free(dup), 0);
        i = 0;
        while (cmd->args[i])
        {
            new_args[i] = cmd->args[i];
            i++;
        }
        free(cmd->args);
        cmd->args = new_args;
    }
    cmd->args[i] = dup;
    cmd->args[i + 1] = NULL;
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_main.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: feanor <feanor@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 11:43:25 by feanor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int is_builtin(const char *cmd)
{
    const char *builtins[] = {"echo", "cd", "pwd", "export", "unset", "env", 
                              "exit", "cat", NULL};
    int i;

    i = 0;
    if (!cmd)
        return (0);
    
    while (builtins[i])
    {
        if (!ft_strncmp(cmd, builtins[i], ft_strlen(builtins[i]) + 1))
            return (1);
        i++;
    }
    return (0);
}

static void validate_command(t_command *cmd)
{
    if (!cmd->args[0] || !cmd->args[0][0])
    {
        cmd->cmdpath = NULL;
        cmd->errormsg = NULL;
        return;
    }
    if (is_builtin(cmd->args[0]))
    {
        cmd->cmdpath = ft_strdup(cmd->args[0]);
        cmd->errormsg = NULL;
    }
    else
    {
        cmd->cmdpath = NULL;
        cmd->errormsg = ft_strdup("command not found");
    }
}

static int process_redirect_token(t_command **current, size_t *i, 
                              t_token_list *tokens)
{
    if (!ft_strncmp(tokens->tokens[*i], "<<", 3))
    {
        (*current)->infiles[0] = ft_strjoin("<<", tokens->tokens[*i + 1]);
        (*i)++;
        return (1);
    }
    else if (!set_redirect(*current, tokens->tokens[*i], tokens->tokens[*i + 1]))
        return (0);
    (*i)++;
    return (1);
}

static int process_pipe_token(t_command **head, t_command **current, int *pipe_flag)
{
	(void)head;
    if (*pipe_flag)
    {
        (*current)->next = init_command();
        if (!(*current)->next)
            return (0);
        *current = (*current)->next;
        *pipe_flag = 0;
        validate_command(*current);
    }
    return (1);
}

t_command *parser(t_token_list *tokens, t_master *master)
{
    t_command   *head;
    t_command   *current;
    size_t      i;
    int         pipe_flag;
    int         result;

    head = init_command();
    if (!head)
        return (NULL);
    current = head;
    i = 0;
    pipe_flag = 0;
    while (i < tokens->count)
    {
        result = process_token(&current, tokens->tokens[i], &pipe_flag, master);
        if (result == 2)
        {
            if (!process_redirect_token(&current, &i, tokens))
                return (free_command(head), NULL);
        }
        else if (!process_pipe_token(&head, &current, &pipe_flag))
            return (free_command(head), NULL);
        i++;
    }
    validate_command(head);
    validate_command(current);
    return (head);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_quotes.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 15:15:41 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*strip_quotes(char *token)
{
	size_t	len;
	char	*result;

	size_t i;
	size_t j;
	if (!token)
		return (NULL);
	len = ft_strlen(token);
	if (len < 1)
		return (ft_strdup(""));
	if (len >= 2 && ((token[0] == '"' && token[len - 1] == '"')
			|| (token[0] == '\'' && token[len - 1] == '\'')))
	{
		if (len == 2)
			return (ft_strdup(""));
		result = malloc(len - 1);
		if (!result)
			return (NULL);
		ft_strlcpy(result, token + 1, len - 1);
		i = 0;
		j = 0;
		while (result[i])
		{
			if ((i + 1 < len - 2) && ((result[i] == '"' && result[i + 1] == '"')
					|| (result[i] == '\'' && result[i + 1] == '\'')))
			{
				i += 2;
				continue ;
			}
			result[j++] = result[i++];
		}
		result[j] = '\0';
		return (result);
	}
	result = malloc(len + 1);
	if (!result)
		return (NULL);
	i = 0;
	j = 0;
	while (i < len)
	{
		if ((i + 1 < len) && ((token[i] == '"' && token[i + 1] == '"')
				|| (token[i] == '\'' && token[i + 1] == '\'')))
		{
			i += 2;
			continue ;
		}
		result[j++] = token[i++];
	}
	result[j] = '\0';
	return (result);
}

int	is_variable(char *token)
{
	if (!token || token[0] != '$')
		return (0);
	if (token[1] == '?' || (token[1] >= 'A' && token[1] <= 'Z'))
		return (1);
	return (0);
}

static char	*get_var_name(char *token, size_t *var_len)
{
	char	*var_name;
	size_t	i;

	*var_len = 0;
	for (i = 1; token[i]; i++)
	{
		if (!(token[i] >= 'A' && token[i] <= 'Z') && !(token[i] >= 'a'
				&& token[i] <= 'z') && !(token[i] >= '0' && token[i] <= '9')
			&& token[i] != '_')
			break ;
		(*var_len)++;
	}
	if (*var_len == 0)
		return (NULL);
	var_name = malloc(*var_len + 1);
	if (!var_name)
		return (NULL);
	for (i = 0; i < *var_len; i++)
		var_name[i] = token[i + 1];
	var_name[*var_len] = '\0';
	return (var_name);
}

char	*expand_variable(char *token, t_master *master)
{
	t_env	*env;
	char	*var_name;
	size_t	var_name_len;

	if (!token || token[0] != '$')
		return (ft_strdup(token));
	if (!ft_strncmp(token, "$?", 2))
		return (ft_itoa(master->errorcode));
	var_name = get_var_name(token, &var_name_len);
	if (!var_name)
		return (ft_strdup("$"));
	env = master->env;
	while (env)
	{
		if (!ft_strcmp(var_name, env->key))
		{
			free(var_name);
			return (ft_strdup(env->value));
		}
		env = env->next;
	}
	free(var_name);
	return (ft_strdup(""));
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_redirects.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: feanor <feanor@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 13:18:59 by feanor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int append_to_array(char ***array, char *new_item)
{
    size_t  count;
    char    **new_array;
    size_t  i;

    count = 0;
    while ((*array)[count])
        count++;
    new_array = malloc(sizeof(char *) * (count + 2));
    if (!new_array)
        return (0);
    i = 0;
    while (i < count)
    {
        new_array[i] = (*array)[i];
        i++;
    }
    new_array[i] = ft_strdup(new_item);
    if (!new_array[i])
    {
        while (i > 0)
            free(new_array[--i]);
        free(new_array);
        return (0);
    }
    new_array[i + 1] = NULL;
    free(*array);
    *array = new_array;
    return (1);
}

static int set_output_redirect(t_command *cmd, char *token, char *stripped_token)
{
    if (!ft_strncmp(token, ">", 2))
    {
        cmd->append = 0;
        if (!append_to_array(&cmd->outfiles, stripped_token))
            return (0);
    }
    else if (!ft_strncmp(token, ">>", 3))
    {
        cmd->append = 1;
        if (!append_to_array(&cmd->outfiles, stripped_token))
            return (0);
    }
    return (1);
}

static int set_input_redirect(t_command *cmd, char *token, char *stripped_token)
{
    if (!ft_strncmp(token, "<", 2))
    {
        if (!append_to_array(&cmd->infiles, stripped_token))
            return (0);
    }
    else if (!ft_strncmp(token, "<<", 3))
    {
        char *heredoc_token = ft_strjoin("<<", stripped_token);
        if (!heredoc_token)
            return (0);
        
        if (!append_to_array(&cmd->infiles, heredoc_token))
        {
            free(heredoc_token);
            return (0);
        }
        
        free(heredoc_token);
    }
    return (1);
}

int set_redirect(t_command *cmd, char *token, char *next_token)
{
    char *stripped_token;
    int result;
    
    if (!next_token)
        return (0);
    
    stripped_token = strip_quotes(next_token);
    if (!stripped_token)
        return (0);
    
    if (token[0] == '>')
        result = set_output_redirect(cmd, token, stripped_token);
    else
        result = set_input_redirect(cmd, token, stripped_token);
    
    free(stripped_token);
    return (result);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_tokens.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: feanor <feanor@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 13:19:17 by feanor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int process_token_pipe(t_parser_data *data)
{
    if (!ft_strncmp(data->token, "|", 2))
    {
        *(data->pipe_flag) = 1;
        return (1);
    }
    return (0);
}

static int process_token_redirect(t_parser_data *data)
{
    if (!ft_strncmp(data->token, ">", 2) || 
        !ft_strncmp(data->token, ">>", 3) || 
        !ft_strncmp(data->token, "<", 2) || 
        !ft_strncmp(data->token, "<<", 3))
        return (2);
    return (0);
}

static int process_token_squote(t_parser_data *data)
{
    char *stripped;
    
    if (data->token[0] == '\'' && ft_strchr(data->token, '\'') > 1)
    {
        stripped = strip_quotes(data->token);
        if (!stripped)
            return (0);
        if (!add_arg(*(data->cmd), stripped))
        {
            free(stripped);
            return (0);
        }
        free(stripped);
        return (1);
    }
    return (0);
}

int process_token(t_command **cmd, char *token, int *pipe_flag, t_master *master)
{
    t_parser_data data;
    int result;
    
    data.cmd = cmd;
    data.token = token;
    data.pipe_flag = pipe_flag;
    data.master = master;
    
    result = process_token_pipe(&data);
    if (result)
        return (result);
    
    result = process_token_redirect(&data);
    if (result)
        return (result);
    
    result = process_token_squote(&data);
    if (result)
        return (result);
    
    if (ft_strchr(token, '$') && (token[0] != '\'' || !ft_strchr(token + 1, '\'')))
        return (process_token_variable(&data));
    else
        return (process_token_normal(&data));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_vars.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 15:01:24 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int process_token_normal(t_parser_data *data)
{
    char *stripped;
    
    stripped = strip_quotes(data->token);
    if (!stripped)
        return (0);
    
    if (!add_arg(*(data->cmd), stripped))
    {
        free(stripped);
        return (0);
    }
    
    free(stripped);
    return (1);
}

static char *get_prefix(char *token, size_t *prefix_len)
{
    *prefix_len = 0;
    while (token[*prefix_len] && token[*prefix_len] != '$')
        (*prefix_len)++;
    
    return (ft_strndup(token, *prefix_len));
}

static size_t get_var_end(char *token, size_t start)
{
    size_t i;
    
    i = start;
    while (token[i] && (
           (token[i] >= 'A' && token[i] <= 'Z') || 
           (token[i] >= 'a' && token[i] <= 'z') || 
           (token[i] >= '0' && token[i] <= '9') || 
           token[i] == '_' || token[i] == '$' || 
           token[i] == '?'))
        i++;
    
    return (i);
}

int process_token_variable(t_parser_data *data)
{
    char *expanded, *prefix, *suffix, *joined, *stripped;
    t_token_list *new_tokens;
    size_t i, prefix_len, suffix_start;
    
    prefix = get_prefix(data->token, &prefix_len);
    
    suffix_start = get_var_end(data->token, prefix_len);
    
    expanded = expand_variable(data->token + prefix_len, data->master);
    
    suffix = ft_strdup(data->token + suffix_start);
    
    if (!prefix || !expanded || !suffix)
    {
        free(prefix);
        free(expanded);
        free(suffix);
        return (0);
    }
    
    joined = ft_strjoin3(prefix, expanded, suffix);
    free(prefix);
    free(expanded);
    free(suffix);
    
    if (!joined)
        return (0);
    
    new_tokens = lexer(joined);
    free(joined);
    
    if (!new_tokens)
        return (0);
    
    i = 0;
    while (i < new_tokens->count)
    {
        stripped = strip_quotes(new_tokens->tokens[i]);
        if (!stripped)
        {
            free_token_list(new_tokens);
            return (0);
        }
        
        if (!add_arg(*(data->cmd), stripped))
        {
            free(stripped);
            free_token_list(new_tokens);
            return (0);
        }
        
        free(stripped);
        i++;
    }
    
    free_token_list(new_tokens);
    return (1);
}
