# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    test.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#              #
#    Updated: 2025/05/02 18:12:49 by mhuthmay         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "minishell.h"

t_command *init_command(void)
{
    t_command   *cmd;

    cmd = malloc(sizeof(t_command));
    if (!cmd)
        return (NULL);
    cmd->args = malloc(sizeof(char *) * 10);
    if (!cmd->args)
        return (free(cmd), NULL);
    cmd->args[0] = NULL;
    cmd->infiles = malloc(sizeof(char *) * 2);
    if (!cmd->infiles)
        return (free(cmd->args), free(cmd), NULL);
    cmd->infiles[0] = NULL;
    cmd->outfiles = malloc(sizeof(char *) * 2);
    if (!cmd->outfiles)
        return (free(cmd->args), free(cmd->infiles), free(cmd), NULL);
    cmd->outfiles[0] = NULL;
    cmd->cmdpath = NULL;
    cmd->errormsg = NULL;
    cmd->append = 0;
    cmd->heredoc_input = NULL;
    cmd->next = NULL;
    return (cmd);
}

void free_command(t_command *cmd)
{
    size_t  i;

    if (!cmd)
        return ;
    i = 0;
    while (cmd->args[i])
        free(cmd->args[i++]);
    free(cmd->args);
    i = 0;
    while (cmd->infiles[i])
        free(cmd->infiles[i++]);
    free(cmd->infiles);
    i = 0;
    while (cmd->outfiles[i])
        free(cmd->outfiles[i++]);
    free(cmd->outfiles);
    free(cmd->cmdpath);
    free(cmd->errormsg);
    free(cmd->heredoc_input);
    free_command(cmd->next);
    free(cmd);
}

int add_arg(t_command *cmd, char *arg)
{
    size_t  i;
    char    *dup;
    char    **new_args;

    if (!arg || arg[0] == '\0')
        return (1);

    dup = ft_strdup(arg);
    if (!dup)
        return (0);
    i = 0;
    while (cmd->args[i])
        i++;
    if (i >= 10)
    {
        new_args = malloc(sizeof(char *) * (i * 2));
        if (!new_args)
            return (free(dup), 0);
        i = 0;
        while (cmd->args[i])
        {
            new_args[i] = cmd->args[i];
            i++;
        }
        free(cmd->args);
        cmd->args = new_args;
    }
    cmd->args[i] = dup;
    cmd->args[i + 1] = NULL;
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_main.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 15:49:22 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int is_builtin(const char *cmd)
{
    const char *builtins[] = {"echo", "cd", "pwd", "export", "unset", "env", 
                              "exit", "cat", NULL};
    int i;

    i = 0;
    if (!cmd)
        return (0);
    
    while (builtins[i])
    {
        if (!ft_strncmp(cmd, builtins[i], ft_strlen(builtins[i]) + 1))
            return (1);
        i++;
    }
    return (0);
}

static void validate_command(t_command *cmd)
{
    if (!cmd->args[0] || !cmd->args[0][0])
    {
        cmd->cmdpath = NULL;
        cmd->errormsg = NULL;
        return;
    }
    if (is_builtin(cmd->args[0]))
    {
        free(cmd->cmdpath);
        cmd->cmdpath = ft_strdup(cmd->args[0]);
        free(cmd->errormsg);
        cmd->errormsg = NULL;
    }
    else
    {
        free(cmd->cmdpath);
        cmd->cmdpath = NULL;
        free(cmd->errormsg);
        cmd->errormsg = ft_strdup("command not found");
    }
}

static int process_redirect_token(t_command **current, size_t *i, 
                              t_token_list *tokens)
{
    if (!ft_strncmp(tokens->tokens[*i], "<<", 3))
    {
        (*current)->infiles[0] = ft_strjoin("<<", tokens->tokens[*i + 1]);
        (*i)++;
        return (1);
    }
    else if (!set_redirect(*current, tokens->tokens[*i], tokens->tokens[*i + 1]))
        return (0);
    (*i)++;
    return (1);
}

static int process_pipe_token(t_command **head, t_command **current, int *pipe_flag)
{
	(void)head;
    if (*pipe_flag)
    {
        (*current)->next = init_command();
        if (!(*current)->next)
            return (0);
        *current = (*current)->next;
        *pipe_flag = 0;
        validate_command(*current);
    }
    return (1);
}

t_command *parser(t_token_list *tokens, t_master *master)
{
    t_command   *head;
    t_command   *current;
    size_t      i;
    int         pipe_flag;
    int         result;

    head = init_command();
    if (!head)
        return (NULL);
    current = head;
    i = 0;
    pipe_flag = 0;
    while (i < tokens->count)
    {
        result = process_token(&current, tokens->tokens[i], &pipe_flag, master);
        if (result == 2)
        {
            if (!process_redirect_token(&current, &i, tokens))
                return (free_command(head), NULL);
        }
        else if (!process_pipe_token(&head, &current, &pipe_flag))
            return (free_command(head), NULL);
        i++;
    }
    validate_command(head);
    validate_command(current);
    return (head);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_quotes.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 17:29:44 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*strip_quotes(char *token)
{
	size_t	len;
	char	*result;

	if (!token)
		return (NULL);
	len = ft_strlen(token);
	if (len == 0)
		return (ft_strdup(""));
	if (len >= 2 && ((token[0] == '"' && token[len - 1] == '"')
			|| (token[0] == '\'' && token[len - 1] == '\'')))
	{
		if (len == 2)
			return (ft_strdup(""));
		result = malloc(len - 1);
		if (!result)
			return (NULL);
		ft_strlcpy(result, token + 1, len - 1);
		return (result);
	}
	return (ft_strdup(token));
}

int	is_variable(char *token)
{
	if (!token || token[0] != '$')
		return (0);
	if (token[1] == '?' || (token[1] >= 'A' && token[1] <= 'Z'))
		return (1);
	return (0);
}

static char	*get_var_name(char *token, size_t *var_len)
{
	char	*var_name;
	size_t	i;

	*var_len = 0;
	i = 1;
	while (token[i])
	{
		if (!(token[i] >= 'A' && token[i] <= 'Z') && !(token[i] >= 'a'
				&& token[i] <= 'z') && !(token[i] >= '0' && token[i] <= '9')
			&& token[i] != '_')
			break ;
		(*var_len)++;
		i++;
	}
	if (*var_len == 0)
		return (NULL);
	var_name = malloc(*var_len + 1);
	if (!var_name)
		return (NULL);
	i = 0;
	while (i < *var_len)
	{
		var_name[i] = token[i + 1];
		i++;
	}
	var_name[*var_len] = '\0';
	return (var_name);
}

char	*expand_variable(char *token, t_master *master)
{
	t_env	*env;
	char	*var_name;
	size_t	var_name_len;

	if (!token || token[0] != '$')
		return (ft_strdup(token));
	if (!ft_strncmp(token, "$?", 2))
		return (ft_itoa(master->errorcode));
	var_name = get_var_name(token, &var_name_len);
	if (!var_name)
		return (ft_strdup("$"));
	env = master->env;
	while (env)
	{
		if (!ft_strcmp(var_name, env->key))
		{
			free(var_name);
			return (ft_strdup(env->value));
		}
		env = env->next;
	}
	free(var_name);
	return (ft_strdup(""));
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_redirects.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: feanor <feanor@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 13:18:59 by feanor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int append_to_array(char ***array, char *new_item)
{
    size_t  count;
    char    **new_array;
    size_t  i;

    count = 0;
    while ((*array)[count])
        count++;
    new_array = malloc(sizeof(char *) * (count + 2));
    if (!new_array)
        return (0);
    i = 0;
    while (i < count)
    {
        new_array[i] = (*array)[i];
        i++;
    }
    new_array[i] = ft_strdup(new_item);
    if (!new_array[i])
    {
        while (i > 0)
            free(new_array[--i]);
        free(new_array);
        return (0);
    }
    new_array[i + 1] = NULL;
    free(*array);
    *array = new_array;
    return (1);
}

static int set_output_redirect(t_command *cmd, char *token, char *stripped_token)
{
    if (!ft_strncmp(token, ">", 2))
    {
        cmd->append = 0;
        if (!append_to_array(&cmd->outfiles, stripped_token))
            return (0);
    }
    else if (!ft_strncmp(token, ">>", 3))
    {
        cmd->append = 1;
        if (!append_to_array(&cmd->outfiles, stripped_token))
            return (0);
    }
    return (1);
}

static int set_input_redirect(t_command *cmd, char *token, char *stripped_token)
{
    if (!ft_strncmp(token, "<", 2))
    {
        if (!append_to_array(&cmd->infiles, stripped_token))
            return (0);
    }
    else if (!ft_strncmp(token, "<<", 3))
    {
        char *heredoc_token = ft_strjoin("<<", stripped_token);
        if (!heredoc_token)
            return (0);
        
        if (!append_to_array(&cmd->infiles, heredoc_token))
        {
            free(heredoc_token);
            return (0);
        }
        
        free(heredoc_token);
    }
    return (1);
}

int set_redirect(t_command *cmd, char *token, char *next_token)
{
    char *stripped_token;
    int result;
    
    if (!next_token)
        return (0);
    
    stripped_token = strip_quotes(next_token);
    if (!stripped_token)
        return (0);
    
    if (token[0] == '>')
        result = set_output_redirect(cmd, token, stripped_token);
    else
        result = set_input_redirect(cmd, token, stripped_token);
    
    free(stripped_token);
    return (result);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_tokens.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 17:43:13 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int process_token_pipe(t_parser_data *data)
{
    if (!ft_strncmp(data->token, "|", 2))
    {
        *(data->pipe_flag) = 1;
        return (1);
    }
    return (0);
}

static int process_token_redirect(t_parser_data *data)
{
    if (!ft_strncmp(data->token, ">", 2) || 
        !ft_strncmp(data->token, ">>", 3) || 
        !ft_strncmp(data->token, "<", 2) || 
        !ft_strncmp(data->token, "<<", 3))
        return (2);
    return (0);
}

static int process_token_word(t_parser_data *data)
{
    char *stripped;

    stripped = strip_quotes(data->token);
    if (!stripped)
        return (0);

    if (stripped[0] != '\0')
    {
        if (!add_arg(*(data->cmd), stripped))
        {
            free(stripped);
            return (0);
        }
    }
    free(stripped);
    return (1);
}

int process_token(t_command **cmd, char *token, int *pipe_flag, t_master *master)
{
    t_parser_data data;
    int result;

    data.cmd = cmd;
    data.token = token;
    data.pipe_flag = pipe_flag;
    data.master = master;

    result = process_token_pipe(&data);
    if (result)
        return (result);

    result = process_token_redirect(&data);
    if (result)
        return (result);

    if (ft_strchr(token, '$') && (token[0] != '\'' || !ft_strchr(token + 1, '\'')))
        return (process_token_variable(&data));

    return (process_token_word(&data));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_vars.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhuthmay <mhuthmay@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 15:30:00 by mhuthmay          #+#    #+#             */
/*   Updated: 2025/05/02 17:23:29 by mhuthmay         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*get_var_name(char *token, size_t *var_len)
{
	char	*var_name;
	size_t	i;

	*var_len = 0;
	i = 1;
	while (token[i])
	{
		if (!(token[i] >= 'A' && token[i] <= 'Z') && !(token[i] >= 'a'
				&& token[i] <= 'z') && !(token[i] >= '0' && token[i] <= '9')
			&& token[i] != '_')
			break ;
		(*var_len)++;
		i++;
	}
	if (*var_len == 0)
		return (NULL);
	var_name = malloc(*var_len + 1);
	if (!var_name)
		return (NULL);
	i = 0;
	while (i < *var_len)
	{
		var_name[i] = token[i + 1];
		i++;
	}
	var_name[*var_len] = '\0';
	return (var_name);
}

int	process_token_variable(t_parser_data *data)
{
	char *expanded, *result, *temp_token;
	t_token_list *new_tokens;
	size_t i, pos, var_len;
	char *new_result;

	result = ft_strdup("");
	if (!result)
		return (0);
	temp_token = data->token;
	pos = 0;
	while (temp_token[pos])
	{
		if (temp_token[pos] == '$')
		{
			expanded = expand_variable(temp_token + pos, data->master);
			if (!expanded)
			{
				free(result);
				return (0);
			}

			new_result = ft_strjoin(result, expanded);
			free(result);
			free(expanded);
			if (!new_result)
				return (0);
			result = new_result;

			get_var_name(temp_token + pos, &var_len);
			pos += var_len + 1;
		}
		else
		{
			size_t start = pos;
			while (temp_token[pos] && temp_token[pos] != '$')
				pos++;

			char *prefix = ft_strndup(temp_token + start, pos - start);
			if (!prefix)
			{
				free(result);
				return (0);
			}
			new_result = ft_strjoin(result, prefix);
			free(result);
			free(prefix);
			if (!new_result)
				return (0);
			result = new_result;
		}
	}

	new_tokens = lexer(result);
	free(result);

	if (!new_tokens)
		return (0);

	i = 0;
	while (i < new_tokens->count)
	{
		char *stripped = strip_quotes(new_tokens->tokens[i]);
		if (!stripped)
		{
			free_token_list(new_tokens);
			return (0);
		}

		if (!add_arg(*(data->cmd), stripped))
		{
			free(stripped);
			free_token_list(new_tokens);
			return (0);
		}

		free(stripped);
		i++;
	}

	free_token_list(new_tokens);
	return (1);
}